[
  {
    "title": "Clean Architecture in the Age of AI: Preventing Architectural Liquefaction",
    "slug": "clean-architecture-ai-preventing-liquefaction",
    "url": "https://dev.to/uxter/clean-architecture-in-the-age-of-ai-preventing-architectural-liquefaction-5d8d",
    "source": "DEV Community",
    "date": "2026-03-02T00:21:21.000Z",
    "summary": "AI has made code execution cheap, but this enables architectural degradationâ€”called 'architectural liquefaction'â€”where boundaries soften and dependencies drift. Clean Architecture serves as a deterministic shell around probabilistic code generation, making structural violations detectable and preventing silent erosion that multiplies costs over time.",
    "content": "AI has made execution cheap; models optimize locally, not for architecture. In many teams the side effect is not bad code or broken builds, but something more structural: architectural liquefaction.\nArchitectural liquefaction is the progressive loss of structural boundaries under sustained probabilistic code generation and accelerated change cycles. It does not happen in one PR â€” layer boundaries soften, dependencies cross the wrong way, contracts drift, invariants weaken, \"temporary\" shortcuts pile up. Everything still works. Until the cost of change quietly multiplies. Without explicit constraints, entropy grows as we ship faster.\nClean Architecture is often described as a layering discipline. But in the context of AI-assisted development, it may serve a different purpose: a deterministic shell around probabilistic execution. Not dogma, not aesthetic preference â€” a stabilizing mechanism. When boundaries are explicit and dependency direction is enforced:\nThe solution space narrows.\nDrift becomes detectable.\nStructural violations surface earlier.\nLocal optimization cannot silently destroy global design.\nThe architecture becomes a control surface.\nBefore AI, architectural violations required effort. A developer had to consciously decide to break a boundary.\nNow, violations can be generated in seconds.\nAnd because AI-generated code often \"looks right\", structural erosion is harder to notice. The real cost is not bad code in the moment; it's that the drift stays invisible until you hit a refactor that suddenly touches half the codebase. One more thing: the more â€œflexibleâ€ and underspecified your prompts and rules are, the faster liquefaction tends to happen â€” the model fills in the gaps in whatever direction is locally easiest.\nI once wrote down all our architectural principles â€” boundaries, dependency rules, what lives where â€” into a docs/ folder in plain Markdown, then wired them into Cursor as project rules so they get injected into every prompt.\ntree ./docs/\n.\nâ”œâ”€â”€",
    "category": "github",
    "translations": {
      "zh": {
        "title": "äººå·¥æ™ºèƒ½æ—¶ä»£çš„æ¸…æ´æ¶æ„ï¼šé˜²æ­¢æ¶æ„æ¶²åŒ–",
        "summary": "äººå·¥æ™ºèƒ½ä½¿ä»£ç æ‰§è¡Œæˆæœ¬ä½å»‰ï¼Œä½†è¿™ä¼šå¯¼è‡´æ¶æ„é€€åŒ–â€”â€”ç§°ä¸º\"æ¶æ„æ¶²åŒ–\"â€”â€”è¾¹ç•Œè½¯åŒ–ï¼Œä¾èµ–å…³ç³»æ¼‚ç§»ã€‚æ¸…æ´æ¶æ„ä½œä¸ºæ¦‚ç‡ä»£ç ç”Ÿæˆå‘¨å›´çš„ç¡®å®šæ€§å¤–å£³ï¼Œä½¿ç»“æ„è¿è§„å¯è¢«æ£€æµ‹ï¼Œé˜²æ­¢æ— å£°ä¾µèš€éšæ—¶é—´å€å¢æˆæœ¬ã€‚"
      },
      "fr": {
        "title": "Architecture Propre Ã  l'Ãˆre de l'IA : PrÃ©venir la LiquÃ©faction Architecturale",
        "summary": "L'IA a rendu l'exÃ©cution du code bon marchÃ©, mais cela permet la dÃ©gradation architecturaleâ€”appelÃ©e Â« liquÃ©faction architecturale Â»â€”oÃ¹ les frontiÃ¨res s'adoucissent et les dÃ©pendances dÃ©rivent. L'Architecture Propre sert de coque dÃ©terministe autour de la gÃ©nÃ©ration de code probabiliste, rendant les violations structurelles dÃ©tectables et prÃ©venant l'Ã©rosion silencieuse qui multiplie les coÃ»ts au fil du temps."
      },
      "de": {
        "title": "Saubere Architektur im Zeitalter der KI: Verhinderung architektonischer VerflÃ¼ssigung",
        "summary": "KI hat Code-AusfÃ¼hrung kostengÃ¼nstig gemacht, aber dies ermÃ¶glicht architektonische Verschlechterungâ€”genannt â€architektonische VerflÃ¼ssigung\"â€”wobei sich Grenzen abschwÃ¤chen und AbhÃ¤ngigkeiten abdriften. Saubere Architektur dient als deterministische HÃ¼lle um probabilische Code-Generierung und macht strukturelle VerstÃ¶ÃŸe erkennbar, wÃ¤hrend stille Erosion verhindert wird, die Kosten im Laufe der Zeit vervielfacht."
      },
      "es": {
        "title": "Arquitectura Limpia en la Era de la IA: Previniendo la LicuefacciÃ³n ArquitectÃ³nica",
        "summary": "La IA ha hecho que la ejecuciÃ³n de cÃ³digo sea barata, pero esto permite la degradaciÃ³n arquitectÃ³nicaâ€”llamada Â«licuefacciÃ³n arquitectÃ³nicaÂ»â€”donde los lÃ­mites se suavizan y las dependencias se desvÃ­an. La Arquitectura Limpia sirve como una capa determinista alrededor de la generaciÃ³n de cÃ³digo probabilÃ­stico, haciendo que las violaciones estructurales sean detectables y previniendo la erosiÃ³n silenciosa que multiplica los costos a lo largo del tiempo."
      }
    }
  },
  {
    "title": "State Management in Jetpack Compose: remember, mutableStateOf, and Beyond",
    "slug": "state-management-jetpack-compose-remember-mutablestateof",
    "url": "https://dev.to/myougatheaxo/state-management-in-jetpack-compose-remember-mutablestateof-and-beyond-4845",
    "source": "DEV Community",
    "date": "2026-03-02T00:20:17.000Z",
    "summary": "State management in Jetpack Compose relies on `remember` and `mutableStateOf` to preserve values across recompositions. Understanding these primitives and state hoisting patterns is essential for building reactive, maintainable Android apps where the UI is a function of state.",
    "content": "State Management in Jetpack Compose: remember, mutableStateOf, and Beyond\n\n\nState management is one of the most crucial aspects of building reactive, user-friendly Android applications with Jetpack Compose. Unlike traditional View-based Android development, Compose embraces a declarative approach where the UI is a function of state. This means understanding how to properly manage state is essential for creating efficient, maintainable, and responsive applications.\nIn this comprehensive guide, we'll explore the various state management tools available in Jetpack Compose, from basic primitives like remember and mutableStateOf to advanced patterns like state hoisting and integration with ViewModel.\nBefore diving into state management, it's important to understand how Compose works. When you write a composable function, it's executed as part of Compose's composition process. As state changes, Compose recomposesâ€”it re-executes composable functions to update the UI.\nThe key challenge: values created locally in a composable function are recreated on every recomposition. This is where state management tools come in.\nThe remember function is the foundation of state management in Compose. It allows you to preserve a value across recompositions:\n@Composable\nfun CounterExample() {\n    var count by remember { mutableStateOf(0) }\n\n    Button(onClick = { count++ }) {\n        Text(\"Clicked $count times\")\n    }\n}\n\nIn this example, count is preserved across recompositions. When the button is clicked, the state updates, triggering a recomposition that reflects the new value.\nmutableStateOf creates a state object that Compose observes. When the state changes, any composables that read that state are recomposed:\n@Composable\nfun LoginForm() {\n    val emailState = remember { mutableStateOf(\"\") }\n    val passwordState = remember { mutableStateOf(\"\") }\n\n    Column {\n        TextField(\n            value = emailState.value,\n            onValueChange = { emailState.value = it },\n            la",
    "category": "github",
    "translations": {
      "zh": {
        "title": "Jetpack Compose ä¸­çš„çŠ¶æ€ç®¡ç†ï¼šrememberã€mutableStateOf åŠå…¶ä»–",
        "summary": "Jetpack Compose ä¸­çš„çŠ¶æ€ç®¡ç†ä¾èµ–äº `remember` å’Œ `mutableStateOf` æ¥åœ¨é‡æ–°ç»„åˆæ—¶ä¿ç•™å€¼ã€‚ç†è§£è¿™äº›åŸºç¡€çŸ¥è¯†å’ŒçŠ¶æ€æå‡æ¨¡å¼å¯¹äºæ„å»ºå“åº”å¼ã€å¯ç»´æŠ¤çš„ Android åº”ç”¨è‡³å…³é‡è¦ï¼Œå…¶ä¸­ UI æ˜¯çŠ¶æ€çš„å‡½æ•°ã€‚"
      },
      "fr": {
        "title": "Gestion des Ã‰tats dans Jetpack Compose : remember, mutableStateOf, et Au-delÃ ",
        "summary": "La gestion des Ã©tats dans Jetpack Compose s'appuie sur `remember` et `mutableStateOf` pour prÃ©server les valeurs lors des recompositions. Comprendre ces primitifs et les modÃ¨les de remontÃ©e d'Ã©tat est essentiel pour construire des applications Android rÃ©actives et maintenables oÃ¹ l'interface utilisateur est une fonction de l'Ã©tat."
      },
      "de": {
        "title": "State-Management in Jetpack Compose: remember, mutableStateOf und darÃ¼ber hinaus",
        "summary": "State-Management in Jetpack Compose basiert auf `remember` und `mutableStateOf`, um Werte Ã¼ber Rekomposita hinweg zu bewahren. Das VerstÃ¤ndnis dieser Primitiven und State-Hoisting-Muster ist fÃ¼r die Erstellung reaktiver, wartbarer Android-Apps wesentlich, bei denen die BenutzeroberflÃ¤che eine Funktion des Zustands ist."
      },
      "es": {
        "title": "GestiÃ³n de Estado en Jetpack Compose: remember, mutableStateOf y MÃ¡s AllÃ¡",
        "summary": "La gestiÃ³n de estado en Jetpack Compose se basa en `remember` y `mutableStateOf` para preservar valores entre recomposiciones. Comprender estos primitivos y los patrones de elevaciÃ³n de estado es esencial para construir aplicaciones Android reactivas y mantenibles donde la interfaz de usuario es una funciÃ³n del estado."
      }
    }
  },
  {
    "title": "Dialogs in Jetpack Compose: AlertDialog, BottomSheet, and Snackbar",
    "slug": "dialogs-jetpack-compose-alertdialog-bottomsheet-snackbar",
    "url": "https://dev.to/myougatheaxo/dialogs-in-jetpack-compose-alertdialog-bottomsheet-and-snackbar-3npo",
    "source": "DEV Community",
    "date": "2026-03-02T00:20:10.000Z",
    "summary": "Jetpack Compose provides three dialog types: AlertDialog for confirmations, ModalBottomSheet for complex interactions, and Snackbar for brief notifications. Each requires proper dismissal handling to prevent stuck dialogs and ensure good user experience.",
    "content": "Dialogs are essential UI components for capturing user attention and collecting input. Jetpack Compose provides multiple dialog types: AlertDialog for simple confirmations, ModalBottomSheet for complex interactions, and Snackbar for brief notifications. This guide covers all three with practical examples.\nAlertDialog is the most common dialog type. It interrupts the user with a modal overlay, requiring explicit action before dismissal.\n@Composable\nfun DeleteConfirmationDialog(\n    onConfirm: () -> Unit,\n    onDismiss: () -> Unit\n) {\n    AlertDialog(\n        onDismissRequest = onDismiss,\n        title = { Text(\"Delete Item\") },\n        text = { Text(\"Are you sure you want to delete this item? This action cannot be undone.\") },\n        confirmButton = {\n            Button(\n                onClick = {\n                    onConfirm()\n                    onDismiss()\n                }\n            ) {\n                Text(\"Delete\")\n            }\n        },\n        dismissButton = {\n            Button(onClick = onDismiss) {\n                Text(\"Cancel\")\n            }\n        }\n    )\n}\n\nCall this from your screen state:\nvar showDeleteDialog by remember { mutableStateOf(false) }\n\nif (showDeleteDialog) {\n    DeleteConfirmationDialog(\n        onConfirm = { deleteItem() },\n        onDismiss = { showDeleteDialog = false }\n    )\n}\n\nButton(onClick = { showDeleteDialog = true }) {\n    Text(\"Delete Item\")\n}\n\nThe key pattern: onDismissRequest fires when the user taps outside the dialog or presses back. Always handle this to prevent stuck dialogs.\nFor collecting text input, add a TextField:\n@Composable\nfun RenameDialog(\n    currentName: String,\n    onConfirm: (String) -> Unit,\n    onDismiss: () -> Unit\n) {\n    var newName by remember { mutableStateOf(currentName) }\n\n    AlertDialog(\n        onDismissRequest = onDismiss,\n        title = { Text(\"Rename\") },\n        text = {\n            TextField(\n                value = newName,\n                onValueChange = { newName = it },",
    "category": "github",
    "translations": {
      "zh": {
        "title": "Jetpack Compose ä¸­çš„å¯¹è¯æ¡†ï¼šAlertDialogã€BottomSheet å’Œ Snackbar",
        "summary": "Jetpack Compose æä¾›ä¸‰ç§å¯¹è¯æ¡†ç±»å‹ï¼šç”¨äºç¡®è®¤çš„ AlertDialogã€ç”¨äºå¤æ‚äº¤äº’çš„ ModalBottomSheet å’Œç”¨äºç®€çŸ­é€šçŸ¥çš„ Snackbarã€‚æ¯ç§éƒ½éœ€è¦é€‚å½“çš„å…³é—­å¤„ç†ï¼Œä»¥é˜²æ­¢å¯¹è¯æ¡†å¡ä½å¹¶ç¡®ä¿è‰¯å¥½çš„ç”¨æˆ·ä½“éªŒã€‚"
      },
      "fr": {
        "title": "Dialogues dans Jetpack Compose : AlertDialog, BottomSheet, et Snackbar",
        "summary": "Jetpack Compose fournit trois types de dialogues : AlertDialog pour les confirmations, ModalBottomSheet pour les interactions complexes, et Snackbar pour les notifications brÃ¨ves. Chacun nÃ©cessite une gestion appropriÃ©e de la fermeture pour Ã©viter les dialogues bloquÃ©s et assurer une bonne expÃ©rience utilisateur."
      },
      "de": {
        "title": "Dialoge in Jetpack Compose: AlertDialog, BottomSheet und Snackbar",
        "summary": "Jetpack Compose bietet drei Dialogtypen: AlertDialog fÃ¼r BestÃ¤tigungen, ModalBottomSheet fÃ¼r komplexe Interaktionen und Snackbar fÃ¼r kurze Benachrichtigungen. Jeder erfordert eine ordnungsgemÃ¤ÃŸe Abschlussverwaltung, um festgefahrene Dialoge zu vermeiden und ein gutes Benutzererlebnis zu gewÃ¤hrleisten."
      },
      "es": {
        "title": "DiÃ¡logos en Jetpack Compose: AlertDialog, BottomSheet y Snackbar",
        "summary": "Jetpack Compose proporciona tres tipos de diÃ¡logos: AlertDialog para confirmaciones, ModalBottomSheet para interacciones complejas y Snackbar para notificaciones breves. Cada uno requiere un manejo de cierre adecuado para evitar diÃ¡logos atascados y garantizar una buena experiencia de usuario."
      }
    }
  },
  {
    "title": "Room Database Migrations: Changing Your Schema Without Losing User Data",
    "slug": "room-database-migrations-changing-schema-without-data-loss",
    "url": "https://dev.to/myougatheaxo/room-database-migrations-changing-your-schema-without-losing-user-data-54ha",
    "source": "DEV Community",
    "date": "2026-03-02T00:19:22.000Z",
    "summary": "Room database migrations transform schemas without losing user data by incrementing version numbers and defining explicit migration paths. Proper migrations are critical in production; mishandled migrations cause crashes and data loss that corrupt user experience.",
    "content": "Introduction\n\n\nRoom Database is Android's abstraction layer over SQLite, providing compile-time checked SQL queries and reactive data flow. As your app evolves, your database schema will inevitably change: adding new columns, changing data types, removing obsolete fields. This is where migrations come in.\nDatabase migrations are one of the trickiest parts of app development. Mishandled migrations can corrupt user data, cause app crashes in production, or result in data loss. In this guide, we'll explore Room's migration system, from basic column additions to advanced schema changes, and how to test them properly.\nWhen you release your app to production and users install it, their local databases are in a specific state defined by your app's schema. When you push an update with schema changes, Room needs to know how to transform the old database to the new one without losing user data.\nConsider this scenario:\nVersion 1 of your app: Users table has id and name columns\nVersion 2 of your app: You want to add an email column\nIf you simply change your Entity definition, Room will see the schema mismatch and throw a crash on app startup. Without a migration, users can't upgrade your app. With a migration, their existing data stays intact while the schema evolves.\nLet's start with the basics. Every Room database has a schema version number:\n@Database(\n    entities = [User::class],\n    version = 1,\n    exportSchema = true\n)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}\n\nWhen you update your schema, increment the version number. Room uses this number to determine which migrations to apply:\n@Database(\n    entities = [User::class],\n    version = 2,  // Updated from 1 to 2\n    exportSchema = true\n)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}\n\nImportant: Always set exportSchema = true. This generates JSON schema files in your build/ directory, which you should commit to version control. These serve as d",
    "category": "github",
    "translations": {
      "zh": {
        "title": "Roomæ•°æ®åº“è¿ç§»ï¼šåœ¨ä¸ä¸¢å¤±ç”¨æˆ·æ•°æ®çš„æƒ…å†µä¸‹æ›´æ”¹æ¶æ„",
        "summary": "Roomæ•°æ®åº“è¿ç§»é€šè¿‡é€’å¢ç‰ˆæœ¬å·å’Œå®šä¹‰æ˜¾å¼è¿ç§»è·¯å¾„æ¥è½¬æ¢æ¶æ„è€Œä¸ä¸¢å¤±ç”¨æˆ·æ•°æ®ã€‚æ­£ç¡®çš„è¿ç§»åœ¨ç”Ÿäº§ç¯å¢ƒä¸­è‡³å…³é‡è¦ï¼›å¤„ç†ä¸å½“çš„è¿ç§»ä¼šå¯¼è‡´å´©æºƒå’Œæ•°æ®ä¸¢å¤±ï¼ŒæŸå®³ç”¨æˆ·ä½“éªŒã€‚"
      },
      "fr": {
        "title": "Migrations Room Database : Modifier Votre SchÃ©ma Sans Perdre de DonnÃ©es Utilisateur",
        "summary": "Les migrations de base de donnÃ©es Room transforment les schÃ©mas sans perdre les donnÃ©es utilisateur en incrÃ©mentant les numÃ©ros de version et en dÃ©finissant des chemins de migration explicites. Les migrations correctes sont essentielles en production ; les migrations mal gÃ©rÃ©es provoquent des plantages et des pertes de donnÃ©es qui corrompent l'expÃ©rience utilisateur."
      },
      "de": {
        "title": "Room-Datenbankmigrationen: Ã„ndern Sie Ihr Schema Ohne Datenverlust",
        "summary": "Room-Datenbankmigrationen transformieren Schemas ohne Datenverlust, indem Versionsnummern erhÃ¶ht und explizite Migrationspfade definiert werden. OrdnungsgemÃ¤ÃŸe Migrationen sind in der Produktion entscheidend; unsachgemÃ¤ÃŸ durchgefÃ¼hrte Migrationen fÃ¼hren zu AbstÃ¼rzen und Datenverlust, die die Benutzererfahrung beeintrÃ¤chtigen."
      },
      "es": {
        "title": "Migraciones de Room Database: Cambiar Tu Schema Sin Perder Datos de Usuario",
        "summary": "Las migraciones de base de datos Room transforman esquemas sin perder datos de usuario incrementando nÃºmeros de versiÃ³n y definiendo rutas de migraciÃ³n explÃ­citas. Las migraciones adecuadas son crÃ­ticas en producciÃ³n; las migraciones mal manejadas causan fallos y pÃ©rdida de datos que corrompen la experiencia del usuario."
      }
    }
  },
  {
    "title": "Jetpack Compose Animations: 4 Techniques to Make Your App Feel Alive",
    "slug": "jetpack-compose-animations-techniques-make-app-feel-alive",
    "url": "https://dev.to/myougatheaxo/jetpack-compose-animations-4-techniques-to-make-your-app-feel-alive-6oo",
    "source": "DEV Community",
    "date": "2026-03-02T00:18:51.000Z",
    "summary": "Jetpack Compose provides four animation techniquesâ€”`animateFloatAsState`, transitions, gesture-driven animations, and keyframe animationsâ€”that transform static UIs into fluid, responsive experiences. These APIs handle smooth state-driven animations with minimal code.",
    "content": "Jetpack Compose Animations: 4 Techniques to Make Your App Feel Alive\n\n\nAnimation is the heartbeat of modern Android apps. It transforms static UIs into fluid, responsive experiences that feel natural and delightful to users. Jetpack Compose, Google's modern declarative UI framework for Android, provides powerful built-in APIs to create smooth animations with just a few lines of code.\nIn this guide, I'll walk you through four essential animation techniques in Compose that will elevate your app's feel from ordinary to exceptional. Each technique comes with practical code examples you can use immediately in your projects.\nanimateFloatAsState is perhaps the most commonly used animation API in Compose. It smoothly animates a float value from its current state to a target value, perfect for opacity fades, scale changes, and rotations.\nimport androidx.compose.animation.core.animateFloatAsState\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.alpha\nimport androidx.compose.ui.graphics.Color\n\n@Composable\nfun AnimatedOpacityButton() {\n    var isPressed by remember { mutableStateOf(false) }\n\n    // Animate opacity from 1.0 to 0.5 when pressed\n    val alpha by animateFloatAsState(\n        targetValue = if (isPressed) 0.5f else 1.0f,\n        label = \"button_alpha\"\n    )\n\n    Button(\n        onClick = { isPressed = !isPressed },\n        modifier = Modifier.alpha(alpha)\n    ) {\n        Text(\"Tap me\")\n    }\n}\n\nSmooth Transitions: The animation runs over 300ms by default, creating a natural fade effect\nState-Driven: The animation automatically triggers whenever the state condition changes\nPerformance: Uses low-level graphics APIs for buttery-smooth 60fps animations\nYou can control animation duration using animationSpec:\nval alpha by animateFloatAsState(\n    target",
    "category": "github",
    "translations": {
      "zh": {
        "title": "Jetpack Compose åŠ¨ç”»ï¼š4 ç§è®©ä½ çš„åº”ç”¨æ ©æ ©å¦‚ç”Ÿçš„æŠ€æœ¯",
        "summary": "Jetpack Compose æä¾›å››ç§åŠ¨ç”»æŠ€æœ¯â€”â€”`animateFloatAsState`ã€è½¬æ¢ã€æ‰‹åŠ¿é©±åŠ¨çš„åŠ¨ç”»å’Œå…³é”®å¸§åŠ¨ç”»â€”â€”å°†é™æ€UIè½¬æ¢ä¸ºæµåŠ¨ã€å“åº”å¼çš„ä½“éªŒã€‚è¿™äº›APIç”¨æœ€å°‘çš„ä»£ç å¤„ç†å¹³æ»‘çš„çŠ¶æ€é©±åŠ¨åŠ¨ç”»ã€‚"
      },
      "fr": {
        "title": "Jetpack Compose Animations : 4 Techniques Pour Rendre Votre Application Vivante",
        "summary": "Jetpack Compose offre quatre techniques d'animation â€” `animateFloatAsState`, transitions, animations pilotÃ©es par gestes et animations d'images clÃ©s â€” qui transforment les interfaces utilisateur statiques en expÃ©riences fluides et rÃ©actives. Ces API gÃ¨rent les animations pilotÃ©es par Ã©tat avec un code minimal."
      },
      "de": {
        "title": "Jetpack Compose Animationen: 4 Techniken, um Ihre App Lebendig Wirken zu Lassen",
        "summary": "Jetpack Compose bietet vier Animationstechniken â€” `animateFloatAsState`, ÃœbergÃ¤nge, gesturegesteuerte Animationen und Keyframe-Animationen â€” die statische UIs in flÃ¼ssige, reaktive Erfahrungen umwandeln. Diese APIs verarbeiten sanfte, zustandsgesteuerte Animationen mit minimalem Code."
      },
      "es": {
        "title": "Jetpack Compose Animaciones: 4 TÃ©cnicas Para Hacer Tu AplicaciÃ³n Cobrar Vida",
        "summary": "Jetpack Compose proporciona cuatro tÃ©cnicas de animaciÃ³n â€” `animateFloatAsState`, transiciones, animaciones impulsadas por gestos y animaciones de fotogramas clave â€” que transforman interfaces de usuario estÃ¡ticas en experiencias fluidas y receptivas. Estas APIs manejan animaciones suave impulsadas por estado con cÃ³digo mÃ­nimo."
      }
    }
  },
  {
    "title": "Implementing Dark Mode in Android with Jetpack Compose: The Complete Guide",
    "slug": "implementing-dark-mode-android-jetpack-compose-complete-guide",
    "url": "https://dev.to/myougatheaxo/implementing-dark-mode-in-android-with-jetpack-compose-the-complete-guide-36bn",
    "source": "DEV Community",
    "date": "2026-03-02T00:17:29.000Z",
    "summary": "Dark mode implementation in Android Compose uses `isSystemInDarkTheme()` for automatic system detection and DataStore for manual user preferences. Dark mode is now a standard expectation, improving user satisfaction, battery life, and accessibility.",
    "content": "Implementing Dark Mode in Android with Jetpack Compose: The Complete Guide\n\n\nDark mode has become a standard expectation for modern Android applications. Users appreciate the reduced eye strain during nighttime usage, and it's become a crucial part of your app's user experience. In this comprehensive guide, we'll explore how to implement dark mode in Android using Jetpack Compose, covering everything from system integration to manual user preferences.\nBefore we dive into implementation, let's understand why dark mode is important:\nUser Preference: Studies show 73% of users prefer dark mode for nighttime usage\nBattery Efficiency: OLED screens consume less power displaying dark pixels\nAccessibility: Reduced eye strain for extended usage periods\nModern Expectation: Users expect dark mode as a baseline feature\nThe isSystemInDarkTheme() function is your gateway to detecting whether the system is currently using dark mode. This composable reads the system's UI mode and returns a boolean indicating dark mode status.\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.darkColorScheme\nimport androidx.compose.material3.lightColorScheme\n\n@Composable\nfun MyAppTheme(\n    darkTheme: Boolean = isSystemInDarkTheme(),\n    content: @Composable () -> Unit\n) {\n    val colorScheme = if (darkTheme) {\n        darkColorScheme()\n    } else {\n        lightColorScheme()\n    }\n\n    MaterialTheme(\n        colorScheme = colorScheme,\n        content = content\n    )\n}\n\nThis approach automatically adapts to system settings. However, many users want manual controlâ€”that's where DataStore comes in.\nDataStore is Android's modern replacement for SharedPreferences, offering a type-safe, coroutine-friendly way to persist user preferences.\ndependencies {\n    implementation \"androidx.datastore:datastore-preferences:1.0.0\"\n    implementation \"androidx.lifecycle:lifecycle-runtime-ktx:2.6.1\"\n}\n\nimport androidx.datastore.core.D",
    "category": "github",
    "translations": {
      "zh": {
        "title": "åœ¨ Android ä¸­ä½¿ç”¨ Jetpack Compose å®ç°æ·±è‰²æ¨¡å¼ï¼šå®Œæ•´æŒ‡å—",
        "summary": "Android Compose ä¸­çš„æ·±è‰²æ¨¡å¼å®ç°ä½¿ç”¨ `isSystemInDarkTheme()` è¿›è¡Œè‡ªåŠ¨ç³»ç»Ÿæ£€æµ‹ï¼Œä½¿ç”¨ DataStore è¿›è¡Œæ‰‹åŠ¨ç”¨æˆ·åå¥½è®¾ç½®ã€‚æ·±è‰²æ¨¡å¼ç°åœ¨æ˜¯æ ‡å‡†é¢„æœŸï¼Œå¯ä»¥æ”¹å–„ç”¨æˆ·æ»¡æ„åº¦ã€ç”µæ± ç»­èˆªæ—¶é—´å’Œå¯è®¿é—®æ€§ã€‚"
      },
      "fr": {
        "title": "ImplÃ©menter le Mode Sombre dans Android avec Jetpack Compose : Le Guide Complet",
        "summary": "L'implÃ©mentation du mode sombre dans Android Compose utilise `isSystemInDarkTheme()` pour la dÃ©tection automatique du systÃ¨me et DataStore pour les prÃ©fÃ©rences utilisateur manuelles. Le mode sombre est dÃ©sormais une attente standard, amÃ©liorant la satisfaction de l'utilisateur, l'autonomie de la batterie et l'accessibilitÃ©."
      },
      "de": {
        "title": "Dunklen Modus in Android mit Jetpack Compose Implementieren: Der VollstÃ¤ndige Leitfaden",
        "summary": "Die Implementierung des dunklen Modus in Android Compose verwendet `isSystemInDarkTheme()` fÃ¼r automatische Systemerkennung und DataStore fÃ¼r manuelle Benutzereinstellungen. Der dunkle Modus ist nun eine Standard-Erwartung, die Benutzerzufriedenheit, Akkulaufzeit und Barrierefreiheit verbessert."
      },
      "es": {
        "title": "Implementar Modo Oscuro en Android con Jetpack Compose: La GuÃ­a Completa",
        "summary": "La implementaciÃ³n del modo oscuro en Android Compose utiliza `isSystemInDarkTheme()` para la detecciÃ³n automÃ¡tica del sistema y DataStore para las preferencias de usuario manuales. El modo oscuro es ahora una expectativa estÃ¡ndar, mejorando la satisfacciÃ³n del usuario, la duraciÃ³n de la baterÃ­a y la accesibilidad."
      }
    }
  },
  {
    "title": "Building Forms in Jetpack Compose: TextField, Validation, and Submission",
    "slug": "building-forms-jetpack-compose-textfield-validation-submission",
    "url": "https://dev.to/myougatheaxo/building-forms-in-jetpack-compose-textfield-validation-and-submission-22f3",
    "source": "DEV Community",
    "date": "2026-03-02T00:17:19.000Z",
    "summary": "Jetpack Compose simplifies form building with TextField, validation patterns, and state hoisting. Well-designed forms reduce friction, catch errors early, and maintain clean, testable code that separates UI state from business logic.",
    "content": "Building Forms in Jetpack Compose: TextField, Validation, and Submission\nForms are a cornerstone of mobile applications. Whether you're collecting user feedback, processing sign-ups, or handling user preferences, you need robust form components. Jetpack Compose, Google's modern declarative UI toolkit for Android, provides powerful tools to build interactive forms with minimal boilerplate. In this comprehensive guide, we'll explore how to construct production-ready forms using TextField, state hoisting, validation patterns, and more.\nUsers interact with forms dailyâ€”logging in, checking out, filling surveys, updating profiles. A well-designed form reduces friction, prevents errors early, and improves user satisfaction. Compose makes it easier than ever to build these forms while maintaining clean, testable code.\nThe most basic form element is TextField. Let's start simple:\n@Composable\nfun SimpleLoginForm() {\n    var email by remember { mutableStateOf(\"\") }\n    var password by remember { mutableStateOf(\"\") }\n\n    Column(modifier = Modifier.padding(16.dp)) {\n        TextField(\n            value = email,\n            onValueChange = { email = it },\n            label = { Text(\"Email\") },\n            modifier = Modifier.fillMaxWidth()\n        )\n\n        TextField(\n            value = password,\n            onValueChange = { password = it },\n            label = { Text(\"Password\") },\n            visualTransformation = PasswordVisualTransformation(),\n            modifier = Modifier.fillMaxWidth()\n        )\n\n        Button(onClick = { /* handle login */ }) {\n            Text(\"Login\")\n        }\n    }\n}\n\nThis works, but mixing UI state with business logic isn't scalable. That's where OutlinedTextField and state hoisting come in.\nOutlinedTextField provides a Material Design outlined style, preferred in modern apps:\n@Composable\nfun ModernLoginForm() {\n    var email by remember { mutableStateOf(\"\") }\n    var password by remember { mutableStateOf(\"\") }\n\n    Column(modifier = Modifier.",
    "category": "github",
    "translations": {
      "zh": {
        "title": "åœ¨Jetpack Composeä¸­æ„å»ºè¡¨å•ï¼šTextFieldã€éªŒè¯å’Œæäº¤",
        "summary": "Jetpack Composeé€šè¿‡TextFieldã€éªŒè¯æ¨¡å¼å’ŒçŠ¶æ€æå‡ç®€åŒ–äº†è¡¨å•æ„å»ºã€‚è®¾è®¡è‰¯å¥½çš„è¡¨å•å‡å°‘äº†æ‘©æ“¦ï¼Œæå‰æ•è·é”™è¯¯ï¼Œå¹¶ç»´æŠ¤æ¸…æ™°ã€å¯æµ‹è¯•çš„ä»£ç ï¼Œå°†UIçŠ¶æ€ä¸ä¸šåŠ¡é€»è¾‘åˆ†ç¦»ã€‚"
      },
      "fr": {
        "title": "CrÃ©ation de formulaires dans Jetpack Compose : TextField, validation et soumission",
        "summary": "Jetpack Compose simplifie la crÃ©ation de formulaires avec TextField, des modÃ¨les de validation et le state hoisting. Les formulaires bien conÃ§us rÃ©duisent les frictions, dÃ©tectent les erreurs tÃ´t et maintiennent un code propre et testable qui sÃ©pare l'Ã©tat de l'interface utilisateur de la logique mÃ©tier."
      },
      "de": {
        "title": "Formulare in Jetpack Compose erstellen: TextField, Validierung und Ãœbermittlung",
        "summary": "Jetpack Compose vereinfacht die Formularerstellung mit TextField, Validierungsmustern und State Hoisting. Gut gestaltete Formulare reduzieren Reibung, fangen Fehler frÃ¼h ab und ermÃ¶glichen sauberen, prÃ¼fbaren Code, der die UI-Status von der GeschÃ¤ftslogik trennt."
      },
      "es": {
        "title": "ConstrucciÃ³n de formularios en Jetpack Compose: TextField, validaciÃ³n y envÃ­o",
        "summary": "Jetpack Compose simplifica la creaciÃ³n de formularios con TextField, patrones de validaciÃ³n y state hoisting. Los formularios bien diseÃ±ados reducen la fricciÃ³n, detectan errores temprano y mantienen cÃ³digo limpio y comprobable que separa el estado de la interfaz de usuario de la lÃ³gica empresarial."
      }
    }
  },
  {
    "title": "DockWatch: Lightweight Docker Monitoring with Anomaly Detection & Telegram Alerts",
    "slug": "dockwatch-lightweight-docker-monitoring-anomaly-detection",
    "url": "https://dev.to/dohelper_0f75b617be84c9bf/dockwatch-lightweight-docker-monitoring-with-anomaly-detection-telegram-alerts-a10",
    "source": "DEV Community",
    "date": "2026-03-02T00:16:55.000Z",
    "summary": "DockWatch is a lightweight, self-hosted Docker monitoring dashboard with real-time metrics, anomaly detection rules, and Telegram alerts. It deploys as a single container with zero configuration and provides visibility into container and host health.",
    "content": "Are you flying blind with your Docker containers? One command changes that.\nI built DockWatch â€” a lightweight, self-hosted Docker monitoring dashboard that gives you full visibility into your containers with zero configuration.\nDockWatch runs as a single Docker container and collects real-time CPU, memory, network, and disk metrics from all your containers and the host machine. Everything is displayed in a clean, dark-themed web UI that auto-refreshes every 10 seconds.\nNo agents to install. No external database. No complex setup. Just mount the Docker socket, run one command, and you're done.\nğŸ“Š Real-time Dashboard â€” Dark-themed UI with sortable tables and Chart.js charts\nğŸ” Container Monitoring â€” CPU %, memory %, network I/O, block I/O, restart count\nğŸŒ¡ï¸ Host Monitoring â€” CPU/GPU temperature, disk usage, load average\nğŸš¨ Anomaly Detection â€” 6 built-in rules: CPU spike, memory overflow, high temp, disk full, unexpected restart, network surge\nğŸ“± Telegram Alerts â€” Instant notifications with 30-minute cooldown per alert type\nğŸ”’ Security â€” Basic Auth, rate limiting, HTTPS (self-signed or Cloudflare Tunnel)\nâš¡ Lightweight â€” Only 4 Python packages, SQLite with 7-day retention\ngit clone https://github.com/deep-on/dockwatch.git && cd dockwatch && bash install.sh\n\nThat's it. The interactive installer sets up authentication, Telegram alerts, and HTTPS in under a minute.\nRequirements: Docker (with Compose v2), Git, OpenSSL\nDockWatch watches your containers 24/7 and alerts you before users notice:\n\n\n\nRule\nCondition\n\n\n\n\nContainer CPU\n>80% for 3 consecutive checks\n\n\nContainer Memory\n>90% of limit\n\n\nHost CPU Temp\n>85Â°C\n\n\nHost Disk\n>90% usage\n\n\nContainer Restart\nrestart_count increased\n\n\nNetwork Spike\nRX 10x surge + >100MB\n\n\n\nAll thresholds are configurable via environment variables.\nLocal Network â€” Self-signed SSL, access via https://localhost:9090\n\n\nRemote Access â€” Port forwarding option\nCloudflare Tunnel â€” Recommended for remote access, no port-forwarding needed, proper TLS certif",
    "category": "github",
    "translations": {
      "zh": {
        "title": "DockWatchï¼šå…·æœ‰å¼‚å¸¸æ£€æµ‹å’ŒTelegramè­¦æŠ¥çš„è½»é‡çº§Dockerç›‘æ§",
        "summary": "DockWatchæ˜¯ä¸€ä¸ªè½»é‡çº§ã€è‡ªæ‰˜ç®¡çš„Dockerç›‘æ§ä»ªè¡¨æ¿ï¼Œå…·æœ‰å®æ—¶æŒ‡æ ‡ã€å¼‚å¸¸æ£€æµ‹è§„åˆ™å’ŒTelegramè­¦æŠ¥ã€‚å®ƒéƒ¨ç½²ä¸ºå•ä¸ªå®¹å™¨ï¼Œé›¶é…ç½®ï¼Œæä¾›å¯¹å®¹å™¨å’Œä¸»æœºå¥åº·çš„å¯è§æ€§ã€‚"
      },
      "fr": {
        "title": "DockWatch : Surveillance lÃ©gÃ¨re de Docker avec dÃ©tection d'anomalies et alertes Telegram",
        "summary": "DockWatch est un tableau de bord de surveillance Docker lÃ©ger et auto-hÃ©bergÃ© avec des mÃ©triques en temps rÃ©el, des rÃ¨gles de dÃ©tection d'anomalies et des alertes Telegram. Il se dÃ©ploie en tant que conteneur unique sans configuration et offre une visibilitÃ© sur la santÃ© des conteneurs et de l'hÃ´te."
      },
      "de": {
        "title": "DockWatch: Leichte Docker-Ãœberwachung mit Anomalieerkennung und Telegram-Benachrichtigungen",
        "summary": "DockWatch ist ein leichtes, selbstverwaltetes Docker-Ãœberwachungs-Dashboard mit Echtzeit-Metriken, Anomalieerkennungsregeln und Telegram-Benachrichtigungen. Es wird als einzelner Container mit Null-Konfiguration bereitgestellt und bietet Transparenz bei der Container- und Host-IntegritÃ¤t."
      },
      "es": {
        "title": "DockWatch: Monitoreo ligero de Docker con detecciÃ³n de anomalÃ­as y alertas de Telegram",
        "summary": "DockWatch es un panel de monitoreo de Docker ligero y autoalojado con mÃ©tricas en tiempo real, reglas de detecciÃ³n de anomalÃ­as y alertas de Telegram. Se implementa como un Ãºnico contenedor sin configuraciÃ³n y proporciona visibilidad sobre la salud de contenedores y hosts."
      }
    }
  },
  {
    "title": "Android App Lifecycle Explained: Why Your AI-Generated App Survives Rotation",
    "slug": "android-app-lifecycle-explained-ai-generated-app-survives-rotation",
    "url": "https://dev.to/myougatheaxo/android-app-lifecycle-explained-why-your-ai-generated-app-survives-rotation-4pbj",
    "source": "DEV Community",
    "date": "2026-03-02T00:15:38.000Z",
    "summary": "The Android Activity lifecycle (onCreate, onStart, onResume, onPause, onStop, onDestroy) determines app behavior and data persistence. Device rotation destroys and recreates Activities, making proper state management essential to prevent data loss.",
    "content": "Android App Lifecycle Explained: Why Your AI-Generated App Survives Rotation\n\n\nWhen you generate an Android app with AI (or write one manually), one of the most critical concepts to understand is the Activity lifecycle. Why? Because your app will crash, rotate, and go to sleepâ€”and if you don't handle it correctly, users will lose their data or see a blank screen. Let's break it down.\nAn Android Activity goes through five main states:\nonCreate() â†’ onStart() â†’ onResume() â†’ [Activity visible and interactive]\n                                              â†“\n                                    onPause() â†’ onStop() â†’ onDestroy()\n\nHere's what each one does:\n1. onCreate()\nCalled when the Activity is first created\nInitialize UI, set up data bindings\nThis is where you restore saved state (more on that later)\n2. onStart()\nActivity is becoming visible to the user\nResources like cameras or location can be started\nNot interactive yet\n3. onResume()\nActivity is now fully interactive\nThe user can tap buttons, input text, etc.\nThis is where you start animations or resume video playback\n4. onPause()\nUser is leaving the Activity (another app came to foreground)\nSave critical data here\nStop animations, pause video\nNote: You have ~500ms before the system kills your app\n5. onStop()\nActivity is no longer visible\nClean up heavy resources like database connections\nThe system might kill your app here to free memory\n6. onDestroy()\nActivity is being destroyed\nEither the user pressed Back, or the system is killing it\nFinal cleanup\nWhen the user rotates their phone, Android does something brutal: it destroys the current Activity and recreates it from scratch.\nHere's the sequence:\nUser rotates phone\n         â†“\nonPause() â†’ onStop() â†’ onDestroy() [old Activity destroyed]\n         â†“\nonCreate() â†’ onStart() â†’ onResume() [new Activity created]\n\nThis means:\nAll local variables are lost\nAny data you were holding in memory is gone\nUI state is reset\nUsers see a flash/flicker as the UI rebuilds\nThis is why ma",
    "category": "github",
    "translations": {
      "zh": {
        "title": "Androidåº”ç”¨ç¨‹åºç”Ÿå‘½å‘¨æœŸè§£é‡Šï¼šä¸ºä»€ä¹ˆæ‚¨çš„AIç”Ÿæˆçš„åº”ç”¨ç¨‹åºå¹¸å­˜æ—‹è½¬",
        "summary": "Android Activityç”Ÿå‘½å‘¨æœŸï¼ˆonCreateã€onStartã€onResumeã€onPauseã€onStopã€onDestroyï¼‰ç¡®å®šäº†åº”ç”¨ç¨‹åºçš„è¡Œä¸ºå’Œæ•°æ®æŒä¹…æ€§ã€‚è®¾å¤‡æ—‹è½¬ä¼šé”€æ¯å¹¶é‡æ–°åˆ›å»ºActivityï¼Œä½¿é€‚å½“çš„çŠ¶æ€ç®¡ç†å¯¹äºé˜²æ­¢æ•°æ®ä¸¢å¤±è‡³å…³é‡è¦ã€‚"
      },
      "fr": {
        "title": "Cycle de vie des applications Android expliquÃ© : pourquoi votre application gÃ©nÃ©rÃ©e par IA survit Ã  la rotation",
        "summary": "Le cycle de vie de l'Activity Android (onCreate, onStart, onResume, onPause, onStop, onDestroy) dÃ©termine le comportement de l'application et la persistance des donnÃ©es. La rotation de l'appareil dÃ©truit et recrÃ©e les Activities, ce qui rend la gestion appropriÃ©e de l'Ã©tat essentielle pour Ã©viter la perte de donnÃ©es."
      },
      "de": {
        "title": "Android-App-Lebenszyklus erklÃ¤rt: Warum Ihre KI-generierte App Rotation Ã¼berlebt",
        "summary": "Der Android Activity-Lebenszyklus (onCreate, onStart, onResume, onPause, onStop, onDestroy) bestimmt das App-Verhalten und die Datenpersistenz. Die GerÃ¤terotation zerstÃ¶rt und erstellt Activities neu, wodurch ordnungsgemÃ¤ÃŸe Zustandsverwaltung unerlÃ¤sslich ist, um Datenverlust zu verhindern."
      },
      "es": {
        "title": "Ciclo de vida de aplicaciones Android explicado: Por quÃ© su aplicaciÃ³n generada por IA sobrevive a la rotaciÃ³n",
        "summary": "El ciclo de vida de Activity de Android (onCreate, onStart, onResume, onPause, onStop, onDestroy) determina el comportamiento de la aplicaciÃ³n y la persistencia de datos. La rotaciÃ³n del dispositivo destruye y recrea Activities, haciendo que la gestiÃ³n adecuada del estado sea esencial para prevenir la pÃ©rdida de datos."
      }
    }
  },
  {
    "title": "Jetpack Compose Layout Fundamentals: Column, Row, Box Explained",
    "slug": "jetpack-compose-layout-fundamentals-column-row-box",
    "url": "https://dev.to/myougatheaxo/jetpack-compose-layout-fundamentals-column-row-box-explained-4hk0",
    "source": "DEV Community",
    "date": "2026-03-02T00:15:32.000Z",
    "summary": "Column, Row, and Box are the three fundamental layout composables in Jetpack Compose that replace traditional XML layouts. These declarative components provide better code reusability, testability, and more intuitive ways to express complex layouts.",
    "content": "Jetpack Compose Layout Fundamentals: Column, Row, Box Explained\n\n\nJetpack Compose has revolutionized Android UI development by introducing a declarative approach to building user interfaces. At the heart of this modern framework lie three fundamental layout composables: Column, Row, and Box. Understanding these building blocks is essential for anyone looking to master Compose and create beautiful, responsive Android applications.\nUnlike traditional XML-based layouts in Android, Jetpack Compose uses composable functions to define UI structure. This functional approach brings several advantages: better code reusability, improved testability, and a more intuitive way to express complex layouts.\nThe three primary layout composablesâ€”Column, Row, and Boxâ€”form the foundation of almost every Compose UI. They provide different ways to arrange and organize child composables, each serving specific layout purposes.\nColumn is a composable that arranges its child elements vertically, stacking them on top of each other from top to bottom. It's the Compose equivalent of LinearLayout with vertical orientation in traditional Android development.\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\n\n@Composable\nfun SimpleColumn() {\n    Column {\n        Text(\"First Item\")\n        Text(\"Second Item\")\n        Text(\"Third Item\")\n    }\n}\n\nIn this example, three Text composables are arranged vertically in the order they appear in the code.\nModifiers are a powerful Compose feature that allow you to decorate or augment a composable. Common modifiers for Column include padding, fillMaxWidth, and size.\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\n\n@Composable\nf",
    "category": "github",
    "translations": {
      "zh": {
        "title": "Jetpack Compose å¸ƒå±€åŸºç¡€ï¼šColumnã€Rowã€Box è¯¦è§£",
        "summary": "Columnã€Row å’Œ Box æ˜¯ Jetpack Compose ä¸­ä¸‰ä¸ªåŸºç¡€å¸ƒå±€ç»„ä»¶ï¼Œç”¨äºæ›¿ä»£ä¼ ç»Ÿçš„ XML å¸ƒå±€ã€‚è¿™äº›å£°æ˜å¼ç»„ä»¶æä¾›æ›´å¥½çš„ä»£ç é‡ç”¨æ€§ã€å¯æµ‹è¯•æ€§å’Œæ›´ç›´è§‚çš„æ–¹å¼æ¥è¡¨è¾¾å¤æ‚å¸ƒå±€ã€‚"
      },
      "fr": {
        "title": "Les fondamentaux des mises en page Jetpack Compose : Column, Row, Box expliquÃ©s",
        "summary": "Column, Row et Box sont les trois composables de mise en page fondamentales de Jetpack Compose qui remplacent les mises en page XML traditionnelles. Ces composants dÃ©claratifs offrent une meilleure rÃ©utilisabilitÃ© du code, une testabilitÃ© et des moyens plus intuitifs d'exprimer des mises en page complexes."
      },
      "de": {
        "title": "Jetpack Compose Layout-Grundlagen: Column, Row, Box erklÃ¤rt",
        "summary": "Column, Row und Box sind die drei fundamentalen Layout-Composables in Jetpack Compose, die traditionelle XML-Layouts ersetzen. Diese deklarativen Komponenten bieten bessere Code-Wiederverwendbarkeit, Testbarkeit und intuitivere MÃ¶glichkeiten, komplexe Layouts auszudrÃ¼cken."
      },
      "es": {
        "title": "Fundamentos de diseÃ±o en Jetpack Compose: Column, Row, Box explicados",
        "summary": "Column, Row y Box son los tres componentes de diseÃ±o fundamentales en Jetpack Compose que reemplazan los diseÃ±os XML tradicionales. Estos componentes declarativos proporcionan mejor reutilizaciÃ³n de cÃ³digo, capacidad de prueba y formas mÃ¡s intuitivas de expresar diseÃ±os complejos."
      }
    }
  },
  {
    "title": "Mastering LazyColumn in Jetpack Compose: Lists Done Right",
    "slug": "mastering-lazycolumn-jetpack-compose-lists-done-right",
    "url": "https://dev.to/myougatheaxo/mastering-lazycolumn-in-jetpack-compose-lists-done-right-2igc",
    "source": "DEV Community",
    "date": "2026-03-02T00:14:13.000Z",
    "summary": "LazyColumn efficiently renders lists by composing only visible items, eliminating RecyclerView boilerplate. Proper use of key parameters prevents recomposition glitches when list order changes, ensuring smooth animations and state preservation.",
    "content": "Jetpack Compose's LazyColumn is the foundation of efficient list rendering in modern Android development. Unlike traditional RecyclerView where you manage viewholders manually, LazyColumn handles composition efficiently by only rendering visible items. Let's explore how to master it.\nTraditional RecyclerView development requires boilerplateâ€”adapters, viewholders, layout inflation. Compose eliminates this. LazyColumn composes only what's visible on screen, garbage collects the rest, and recomposes when state changes. Performance is automatic.\nLazyColumn {\n    items(items.size) { index ->\n        Text(\"Item $index\")\n    }\n}\n\nThat's it. No adapter. No viewholder. Just pure composable logic.\nitems() is for simple iterations. Use it when you don't need the index:\ndata class Book(val id: Int, val title: String, val author: String)\n\nval books = listOf(\n    Book(1, \"Kotlin in Action\", \"Jemerov\"),\n    Book(2, \"Clean Code\", \"Martin\"),\n    Book(3, \"The Pragmatic Programmer\", \"Hunt\")\n)\n\nLazyColumn {\n    items(books) { book ->\n        BookItem(book)\n    }\n}\n\n@Composable\nfun BookItem(book: Book) {\n    Column(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(16.dp)\n            .border(1.dp, Color.Gray)\n    ) {\n        Text(book.title, fontSize = 18.sp, fontWeight = FontWeight.Bold)\n        Text(book.author, fontSize = 14.sp, color = Color.Gray)\n    }\n}\n\nUse itemsIndexed() when you need both value and position:\nLazyColumn {\n    itemsIndexed(books) { index, book ->\n        BookItem(book, index)\n    }\n}\n\n@Composable\nfun BookItem(book: Book, index: Int) {\n    Column(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(16.dp)\n    ) {\n        Text(\"${index + 1}. ${book.title}\", fontSize = 18.sp, fontWeight = FontWeight.Bold)\n        Text(book.author, fontSize = 14.sp, color = Color.Gray)\n    }\n}\n\nThis is critical. Without key, LazyColumn recomposes items when the list order changes, causing animation glitches and state loss.\n// BAD: I",
    "category": "github",
    "translations": {
      "zh": {
        "title": "æŒæ¡ Jetpack Compose ä¸­çš„ LazyColumnï¼šæ­£ç¡®å¤„ç†åˆ—è¡¨",
        "summary": "LazyColumn é€šè¿‡åªç»„åˆå¯è§é¡¹ç›®æ¥æœ‰æ•ˆåœ°æ¸²æŸ“åˆ—è¡¨ï¼Œæ¶ˆé™¤äº† RecyclerView çš„æ ·æ¿ä»£ç ã€‚æ­£ç¡®ä½¿ç”¨ key å‚æ•°å¯é˜²æ­¢åˆ—è¡¨é¡ºåºæ›´æ”¹æ—¶çš„é‡æ–°ç»„åˆé—®é¢˜ï¼Œç¡®ä¿å¹³æ»‘çš„åŠ¨ç”»å’ŒçŠ¶æ€ä¿æŒã€‚"
      },
      "fr": {
        "title": "MaÃ®triser LazyColumn dans Jetpack Compose : Listes faites correctement",
        "summary": "LazyColumn rend efficacement les listes en composant uniquement les Ã©lÃ©ments visibles, Ã©liminant le code standard de RecyclerView. L'utilisation appropriÃ©e des paramÃ¨tres de clÃ© empÃªche les glitches de recomposition lorsque l'ordre de la liste change, en assurant des animations fluides et la prÃ©servation de l'Ã©tat."
      },
      "de": {
        "title": "LazyColumn in Jetpack Compose beherrschen: Listen richtig gemacht",
        "summary": "LazyColumn rendert Listen effizient, indem es nur sichtbare Elemente zusammensetzt und RecyclerView-Boilerplate Code eliminiert. Die ordnungsgemÃ¤ÃŸe Verwendung von SchlÃ¼sselparametern verhindert Rekompositionsfehler, wenn sich die Listenreihenfolge Ã¤ndert, und gewÃ¤hrleistet reibungslose Animationen und Zustandsbewahrung."
      },
      "es": {
        "title": "Dominar LazyColumn en Jetpack Compose: Listas bien hechas",
        "summary": "LazyColumn renderiza listas de manera eficiente al componer solo elementos visibles, eliminando el cÃ³digo estÃ¡ndar de RecyclerView. El uso adecuado de parÃ¡metros de clave previene fallas de recomposiciÃ³n cuando cambia el orden de la lista, asegurando animaciones fluidas y preservaciÃ³n de estado."
      }
    }
  },
  {
    "title": "Signing Your Android APK: From Keystore to Google Play",
    "slug": "signing-android-apk-keystore-to-google-play",
    "url": "https://dev.to/myougatheaxo/signing-your-android-apk-from-keystore-to-google-play-296a",
    "source": "DEV Community",
    "date": "2026-03-02T00:14:07.000Z",
    "summary": "APK signing proves app authenticity and integrity to Google Play and Android devices using a private keystore. Developers generate a keystore with keytool, sign the APK, and manage credentials through Google Play's systems for app updates.",
    "content": "Signing Your Android APK: From Keystore to Google Play\n\n\nIf you've built an Android app and want to release it on Google Play, you'll need to sign your APK. This comprehensive guide walks you through the entire signing processâ€”from generating your keystore to managing your signing credentials in Google Play.\nAPK signing serves two critical purposes:\nAuthenticity: It proves to Android that you're the legitimate developer of the app\nIntegrity: It ensures the APK hasn't been modified after signing\nGoogle Play and Android devices require valid signatures before installation. Without proper signing, your app simply won't run on devices.\nA keystore is a binary file containing your private signing key. Think of it as your app's digital passportâ€”keep it safe, because losing it means you can't update your app on Google Play.\nkeytool -genkey -v -keystore my-release-key.keystore \\\n  -keyalg RSA -keysize 2048 -validity 10000 \\\n  -alias my-key-alias\n\nWhat each flag means:\n-genkey: Generate a new key pair\n-v: Verbose output\n-keystore: Output file name\n-keyalg RSA: Use RSA algorithm (industry standard)\n-keysize 2048: 2048-bit encryption (minimum recommended)\n-validity 10000: Valid for ~27 years\n-alias: Internal name for this key\nThe command will prompt for:\nKeystore password (e.g., MySecurePass123!)\nKey password (can be same as keystore password)\nYour name, organization, location\nExample output:\nGenerating 2,048 bit RSA key pair and self-signed certificate...\nEnter keystore password: ****\nRe-enter new password: ****\nWhat is your first and last name?\n  [Unknown]:  John Developer\nWhat is the name of your organizational unit?\n  [Unknown]:  Mobile Apps\nWhat is the name of your organization?\n  [Unknown]:  MyCompany Inc\nWhat is the name of your City or Locality?\n  [Unknown]:  San Francisco\nWhat is the name of your State or Province?\n\nWhat is the two-letter country code for this location?\n\n\nAfter completion, you'll have my-release-key.keystore file ready.\nStore your keystore securely and",
    "category": "github",
    "translations": {
      "zh": {
        "title": "ç­¾ç½² Android APKï¼šä»å¯†é’¥åº“åˆ° Google Play",
        "summary": "APK ç­¾ç½²ä½¿ç”¨ç§é’¥åº“å‘ Google Play å’Œ Android è®¾å¤‡è¯æ˜åº”ç”¨çš„çœŸå®æ€§å’Œå®Œæ•´æ€§ã€‚å¼€å‘è€…ä½¿ç”¨ keytool ç”Ÿæˆå¯†é’¥åº“ï¼Œç­¾ç½² APKï¼Œå¹¶é€šè¿‡ Google Play ç³»ç»Ÿç®¡ç†å‡­è¯ä»¥è¿›è¡Œåº”ç”¨æ›´æ–°ã€‚"
      },
      "fr": {
        "title": "Signer votre APK Android : Du Keystore Ã  Google Play",
        "summary": "La signature APK prouve l'authenticitÃ© et l'intÃ©gritÃ© de l'application Ã  Google Play et aux appareils Android Ã  l'aide d'un keystore privÃ©. Les dÃ©veloppeurs gÃ©nÃ¨rent un keystore avec keytool, signent l'APK et gÃ¨rent les identifiants via les systÃ¨mes de Google Play pour les mises Ã  jour d'application."
      },
      "de": {
        "title": "Signieren Sie Ihre Android APK: Vom Keystore zu Google Play",
        "summary": "Das APK-Signieren beweist Google Play und Android-GerÃ¤ten die AuthentizitÃ¤t und IntegritÃ¤t der App mit Hilfe eines privaten Keystores. Entwickler generieren einen Keystore mit keytool, signieren die APK und verwalten Anmeldeinformationen Ã¼ber Google Play-Systeme fÃ¼r App-Updates."
      },
      "es": {
        "title": "Firma tu APK de Android: Del Keystore a Google Play",
        "summary": "La firma de APK prueba la autenticidad e integridad de la aplicaciÃ³n a Google Play y dispositivos Android usando un almacÃ©n de claves privado. Los desarrolladores generan un almacÃ©n de claves con keytool, firman el APK y administran credenciales a travÃ©s de los sistemas de Google Play para actualizaciones de aplicaciones."
      }
    }
  }
]